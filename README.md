# 📸 HabitSnap 🍽️
**사진 한 장으로 나의 식습관을 기록하다**

[사진 기반 식사 기록 관리 백엔드 서비스]

HabitSnap은 식사 사진과 간단한 정보를 함께 기록하여  
사용자가 자신의 식습관을 쉽게 관리할 수 있도록 돕는 백엔드 서비스입니다.

단순히 기능을 구현하는 데서 끝나지 않고,  
**인증, 부분 업데이트, 성능 개선, API 문서화까지**  
백엔드 개발 전반을 경험하는 것을 목표로 개발했습니다.

---

## 🌿 프로젝트 개요

**HabitSnap**은 사용자가 식사 사진을 업로드하면
사진의 **촬영 일시(EXIF 메타데이터)** 를 자동으로 읽어
식사 날짜와 시간을 자동 기록하는 서비스입니다.

사용자는 직접 `식사 유형`, `메뉴명`, `탄단지(탄수화물·단백질·지방)`, `먹은 양`, `포만감` 등을 입력하며
자신의 식습관을 인식하고 개선해 나갑니다.

---

## 🎯 핵심 기능

### 📸 자동 기록 기능
- 식사 사진 업로드 시 EXIF 메타데이터 분석
- 사진 촬영 시각을 기준으로 식사 날짜·시간 자동 저장
- 사용자가 직접 입력하지 않아도 자연스러운 기록 가능

### 🍱 식사 기록 관리
- 식사 사진을 포함한 기록 등록
- 식사 기록 단건 조회 및 날짜별 조회
- 식사 기록 수정 및 삭제

### 🔷 부분 수정(PATCH) API
- 수정할 필드만 전달하는 PATCH 방식 지원
- 전달되지 않은 값은 기존 데이터 유지
- 사용자가 수정 의도를 명확히 표현할 수 있도록 설계

### 🔐 JWT 기반 사용자 인증
- 로그인 시 JWT 토큰 발급
- 인증된 사용자만 식사 기록 API 접근 가능
- Spring Security를 이용해 인증 처리

### 📄 Swagger 기반 API 문서화
- Swagger 자동 생성 문서 활용
- 요청/응답 예시 제공
- 인증 → 사용자 → 식사 기록 흐름에 맞춘 API 구성
- 문서만 보고도 API를 테스트할 수 있도록 구성

---

## 🛠 기술 스택 및 선택 이유

### Backend
- **Java 17**  
  장기 지원 버전(LTS)으로 안정적인 개발 환경을 위해 선택

- **Spring Boot**  
  설정 부담을 줄이고 비즈니스 로직에 집중하기 위해 사용

- **Spring Security + JWT**  
  서버 상태를 저장하지 않는 인증 방식으로 확장성과 보안을 고려

- **Spring Data JPA**  
  객체 중심으로 도메인을 설계하고 반복적인 CRUD 코드 감소

### Database
- **MySQL**  
  관계형 데이터 구조에 적합하며 JPA와의 호환성이 좋아 선택

### Tool
- **Swagger (springdoc-openapi)**  
  API 문서를 자동으로 생성하고 사용성을 높이기 위해 사용

- **Gradle / GitHub**  
  빌드 관리 및 버전 관리

---

## 🧠 문제 해결 사례  

### ⚙️ DB 성능 개선 및 최적화 (Performance Optimization)

### 🧩 문제 상황 및 배경
HabitSnap은 **사용자별·날짜별 식사기록 조회**가 핵심 기능으로,  
데이터가 누적될수록 **조회 성능 저하가 발생할 가능성**이 있는 구조였습니다.  

이에 따라  
- **설계 단계**에서는 `user_id + meal_date` 기반의 **복합 인덱스**를 미리 고려하여  
  대량 데이터 환경에서도 안정적인 조회 성능을 확보할 수 있도록 설계했고,  
- **개발 과정**에서는 실제 조회 기능을 구현하면서  
  **쿼리 최적화(EntityGraph)** 와 **캐싱(Caffeine Cache)** 이  
  조회 성능을 실질적으로 향상시킬 수 있음을 확인하고 적용했습니다.  

결과적으로 HabitSnap은 **“사전 설계 + 실측 기반 최적화”** 두 단계를 거쳐  
데이터 접근 효율과 응답 속도를 모두 개선한 구조로 발전했습니다.


### 🎯 개선 목표
- Full Table Scan 제거 및 조회 효율 향상  
- N+1 쿼리 제거를 통한 DB 왕복 횟수 최소화  
- 반복 조회를 캐싱하여 응답 속도 개선 및 부하 완화  


### ⚡  해결 과정
#### 1️⃣ **인덱스 설계 및 검증**
- `meal_record` 테이블에 **복합 인덱스(`user_id + meal_date`)** 설계 및 적용  
- `SHOW INDEX`, `EXPLAIN`을 통해 실제 Range Scan 동작 검증  
- **Full Table Scan → Range Scan** 으로 전환됨을 확인

#### 2️⃣ **N+1 쿼리 제거**
- `MealRecord` ↔ `User` 간 Lazy 로딩으로 인한 **N+1 문제** 발생  
- `@EntityGraph(attributePaths = "user")` 적용 → **JOIN FETCH 전략**으로 개선  
- **쿼리 수 6 → 1 (−83%)**, **실행 시간 158ms → 53ms (−66%)**  

#### 3️⃣ **캐시 적용 (Caffeine Cache)**
- 동일 사용자의 주간 리포트 조회 API(`getMealRecordsByPeriod`)에 캐시 도입  
- `@Cacheable` / `@CacheEvict` 로 캐시 갱신 및 데이터 일관성 유지  
- **1회차 DB 조회 496ms → 캐시 HIT 시 5ms (약 100배 향상)**  
- 반복 조회 시 **DB 부하 감소 + 서버 응답속도 개선**


### 📊 성과 및 지표
| 구분 | 개선 전 | 개선 후 | 개선 효과 |
|------|----------|----------|------------|
| **조회 방식** | Full Table Scan | Range Scan | 조회 효율 향상 |
| **쿼리 실행 횟수** | 6회 | 1회 | **−83% 감소** |
| **쿼리 실행 시간** | 158ms | 53ms | **−66% 단축** |
| **기간별 조회 응답 시간** | 496ms | 5ms | **약 100배 향상** |
| **DB 부하** | 동일 요청마다 재조회 | 캐시 재사용 | DB I/O 최소화 |



### 🧠 Insight
> 설계 단계부터 인덱스를 고려하고,  
> 개발 과정에서 `@EntityGraph`와 `Caffeine Cache`를 적용하여  
> **조회 효율성·데이터 일관성·응답 성능**을 모두 확보했습니다.  
>  
> HabitSnap은 단계별 성능 개선 과정을 통해
조회 효율을 높이고, 
> 향후 확장에도 대응할 수 있는 백엔드 구조를 구축했습니다.

---

### 1️⃣ PATCH API 부분 수정 방식 설계

**문제**  
수정 API에서 어떤 값이 수정되고, 어떤 값이 유지되는지 기준이 모호했습니다.

**해결**  
PATCH의 목적에 맞게  
→ *요청으로 전달된 필드만 수정하고, 전달되지 않은 필드는 그대로 유지*하도록 정책을 정했습니다.  
식별자(id)는 요청 바디가 아닌 PathVariable로만 전달하도록 구조를 수정했습니다.

**결과**
- 수정 의도가 명확한 API 구현
- 불필요한 데이터 변경 방지
- PATCH 방식에 맞는 안정적인 업데이트 로직 완성

---

### 2️⃣ Swagger 문서 복잡도 문제

**문제**  
Swagger 문서를 세밀하게 커스터마이징할수록  
문서가 복잡해지고 유지보수가 어려워졌습니다.

**해결**  
Swagger의 자동 생성 기능을 기본으로 사용하고,  
요청/응답 예시와 꼭 필요한 설명만 추가했습니다.

**결과**
- 문서와 실제 API 동작 간 불일치 감소
- 읽기 쉬운 API 문서 완성
- API 엔드포인트를 실제 실행 흐름에 맞게 순서대로 정리
- 각 API를 쉽게 실행하고 테스트할 수 있도록 설명과 예시를 추가

---

### 3️⃣ LocalTime 응답 표현 문제

**문제**  
`LocalTime` 타입이 응답에서 객체 형태로 노출되어  
문서 가독성과 프론트엔드 사용성이 떨어졌습니다.

**해결**  
응답 DTO에서 시간 값을 문자열(`HH:mm:ss`)로 변환해 반환하도록 수정했습니다.

**결과**
- Swagger 응답 예시와 실제 응답 형식 통일
- 프론트엔드에서 추가 가공 없이 바로 사용 가능

---

### 4️⃣ 캐시 무효화 오류 해결

**문제**  
`@CacheEvict` 설정 중 SpEL 표현식에서 null 에러가 발생했습니다.

**해결**  
SpEL이 파라미터 이름을 인식하지 못하는 문제임을 확인하고,  
파라미터 인덱스 기반 접근 방식으로 수정했습니다.

**결과**
- 캐시 무효화 정상 동작
- Spring 캐시와 AOP 동작 방식에 대한 이해도 향상

---

## ✨ 프로젝트를 통해 얻은 점

- 기능 구현보다 **왜 이렇게 설계했는지**를 고민하는 습관
- API는 단순히 동작하는 것보다
**사용자가 어떻게 쓰는지와 그 규칙을 명확히 하는 것이 더 중요하다고 인식**
- 인증, 성능, 문서화를 포함한 **백엔드 개발 전체 흐름 경험**
- 사용자별·날짜별 조회 패턴을 분석해 **인덱스 설계·쿼리 최적화·캐싱 적용**의 효과를 직접 검증
- 단순한 코드 개선을 넘어 **DB 접근 효율과 응답 속도를 함께 향상시키는 설계 사고**를 배움

---

## 📌 한 줄 요약
> HabitSnap은 식사 기록이라는 작은 도메인을 통해  
> 백엔드 개발자가 마주치는 설계와 문제 해결 과정을  
> 직접 고민하고 구현한 프로젝트입니다.

## 💡 프로젝트 요약 문장
> “HabitSnap은 사진을 찍는 순간이 곧 나의 식습관 기록이 되는 서비스입니다.”           
> 사용자의 기록 부담을 최소화하고, 꾸준한 습관 형성을 돕는 것이 목표입니다.
